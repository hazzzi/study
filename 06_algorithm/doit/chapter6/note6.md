# 정렬 알고리즘

## 정렬(sorting)
- 키를 항목값의 대소 관계에 따라 데이터 집합을 일정한 순서로 바꾸어 늘어놓는 작업
- 오름차순(ascending), 내림차순(decending)
- 안정적인 알고리즘(stable): 같은 원소의 순서가 정렬 후에도 유지
- 내부 정렬(internal sorting): 정렬할 모든 데이터를 하나에 배열에 저장할 수 있는 경우에 사용
- 외부 정렬(external sorting): 정렬할 데이터가 많아서 하나의 배열에 저장할 수 없는 경우에 사용

## 버블 정렬(bubble sort)
- 이웃한 두 원소의 대소관계를 비교, 교환을 반복하며 정렬
- pass: 비교, 교환 과정
- 원소를 비교하는 횟수: (n-1)+(n-2)+...+1 = n(n-1) / 2
- 양방향 버블 정렬: 홀수 패스에서 가장 작은 원소를 맨 앞으로 이동, 짝수 패스에서 가장 큰 원소를 맨 뒤로 이동 ==> 패스의 스캔 방향을 번갈아 바꿈

## 단순 선택 정렬(straight selection sort)
- 가장 작은 원소부터 선택해 알맞은 위치로 옮기는 작업을 반복하며 정렬
- 교환 과정
  1. 아직 정렬하지 않은 부분에서 값이 가장 작은 원소 a[min]을 선택
  2. a[min]과 아직 정렬하지 않은 부분에서 맨 앞에있는 원소를 교환
- 비교 횟수: (n^2 - n) / 2

## 단순 삽입 정렬(straight insertion sort)
- 셔틀 정렬(shuttle sort)
- 아직 정렬되지 않은 부분의 맨 앞 원소를 정렬된 부분의 알맞은 위치에 삽입
- bisect.insort()
- 비교 횟수: n^2 / 2
- 
    ```py
    for i in range(1, n):
        tmp <- a[i]를 넣는다
        tmp를 a[0], ..., a[i - 1]의 알맞은 위치에 삽입
    ```
- 종료 조건
  1. 정렬된 배열의 왼쪽 끝에 도달한 경우
  2. tmp보다 작거나 키값이 같은 원소 a[j - 1]을 발견한 경우
- 계속 조건
  1. j가 0보다 큰경우
  2. a[j - 1]의 값이 tmp보다 큰 경우
- 장점: 이미 정렬을 마쳤거나 정렬이 거의 끝나가는 상태에서는 빠름
- 단점: 삽입할 위치가 멀리 떨어져있으면 이동 횟수가 많아짐

## 셸 정렬(shell sort)
- 단순 삽입정렬을 개선한 알고리즘
- 정렬할 배열의 원소를 그룹으로나눠서 그룹별로 정렬 수행
- [참고 링크](https://ko.wikipedia.org/wiki/%EC%85%B8_%EC%A0%95%EB%A0%AC)

## 퀵 정렬(quick sort)
- 배열을 두 그룹으로 나눔
  - a[pl] >= x 가 성립하는 원소를 찾을 떄 까지 pl을 오른쪽 방향으로 스캔
  - a[pr] <= x 가 성립하는 원소를 찾을 떄 까지 pr을 왼쪽 방향으로 스캔
  - pl 과 pr이 교차하면 그룹을 나누는 과정이 끝남
  - 피벗 이하인 그룹: a[0], ... , a[pl - 1]
  - 피벗 이상인 그룹: a[pr + 1], ... , a[n - 1]
  - 피벗과 일치하는 그룹: a[pr + 1], ... , a[pl - 1] (pl > pr + 1일 경우에)
- 피벗 선택하기
  1. 나누어야 할 배열의 원소수가 3이상이면 배열에서 임의의 원소 3개를 꺼내 중앙값인 원소를 피벗으로 선택
  2. 나누어야 할 배열의 맨 앞 원소, 가운데 원소, 맨 끝 원소를 정렬한 뒤 가운데 원소와 맨끝에서 두 번째 원소를 교환, 맨끝에서 두번째 원솟값 a[right - 1]이 피벗으로 선택되었고, 그 동시에 나눌 대상을 a[left + 1] ~ a[right - 2]로 좁힌다.
- 시간 복잡도: O(n log n) <= O <= O(n^2)

- [참고 링크](https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC)

## 병합 정렬(merge sort)
- 배열을 앞부분과 뒷부분의 두 그룹으로 나누어 각각 정렬 후 병합
- 서로 떨어져있는 원소를 교환하는게 아니므로 안정적
- 배열의 원소 수가 2개 이상인 경우
  1. 배열 앞부분을 병합 정렬로 정렬
  2. 배열 뒷부분을 병합 정렬로 정렬
  3. 배열 앞부분과 뒷부분을 병합
- 시간 복잡도: O(n log n)

## 힙 정렬(heap sort)
- heap: `부모의 값과 자식의 값의 대소관계가 일정하다`를 만족하는 완전 이진 트리
- 형제의 대소 관계를 정해져 있지 않음
- root: 힙의 가장 위쪽에 위치한 값
- 원소 a[i]에서
  - 부모: a[(i - 1) // 2]
  - 왼쪽 자식: a[i * 2 + 1]
  - 오른쪽 자식: a[i * 2 + 2]
- 힙의 재구성 과정
  1. 힙에서 최댓값인 루트를 꺼낸다
  2. 마지막 원소(가장 하단의 오른쪽 원소)를 루트로 이동
  3. 루트에서 시작하여 자신보다 값이 큰 자식과 자리를 바꾸고 내려가는 과정 반복
- 정렬 과정 (배열은 반드시 힙이어야함)
  1. i 값을 n-1로 초기화
  2. a[0]과 a[i]를 교환
  3. a[0], a[i], ... , a[i -1]을 힙으로 만든다
  4. i값을 1씩 감소시켜 0이 되면 종료, 그렇지 않으면 2로 돌아감
- 시간 복잡도: O(n log n)
   