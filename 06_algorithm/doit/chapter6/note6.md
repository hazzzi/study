# 정렬 알고리즘

## 정렬(sorting)
- 키를 항목값의 대소 관계에 따라 데이터 집합을 일정한 순서로 바꾸어 늘어놓는 작업
- 오름차순(ascending), 내림차순(decending)
- 안정적인 알고리즘(stable): 같은 원소의 순서가 정렬 후에도 유지
- 내부 정렬(internal sorting): 정렬할 모든 데이터를 하나에 배열에 저장할 수 있는 경우에 사용
- 외부 정렬(external sorting): 정렬할 데이터가 많아서 하나의 배열에 저장할 수 없는 경우에 사용

## 버블 정렬(bubble sort)
- 이웃한 두 원소의 대소관계를 비교, 교환을 반복하며 정렬
- pass: 비교, 교환 과정
- 원소를 비교하는 횟수: (n-1)+(n-2)+...+1 = n(n-1) / 2
- 양방향 버블 정렬: 홀수 패스에서 가장 작은 원소를 맨 앞으로 이동, 짝수 패스에서 가장 큰 원소를 맨 뒤로 이동 ==> 패스의 스캔 방향을 번갈아 바꿈

## 단순 선택 정렬(straight selection sort)
- 가장 작은 원소부터 선택해 알맞은 위치로 옮기는 작업을 반복하며 정렬
- 교환 과정
  1. 아직 정렬하지 않은 부분에서 값이 가장 작은 원소 a[min]을 선택
  2. a[min]과 아직 정렬하지 않은 부분에서 맨 앞에있는 원소를 교환
- 비교 횟수: (n^2 - n) / 2

## 단순 삽입 정렬(straight insertion sort)
- 셔틀 정렬(shuttle sort)
- 아직 정렬되지 않은 부분의 맨 앞 원소를 정렬된 부분의 알맞은 위치에 삽입
- bisect.insort()
- 비교 횟수: n^2 / 2
- 
    ```py
    for i in range(1, n):
        tmp <- a[i]를 넣는다
        tmp를 a[0], ..., a[i - 1]의 알맞은 위치에 삽입
    ```
- 종료 조건
  1. 정렬된 배열의 왼쪽 끝에 도달한 경우
  2. tmp보다 작거나 키값이 같은 원소 a[j - 1]을 발견한 경우
- 계속 조건
  1. j가 0보다 큰경우
  2. a[j - 1]의 값이 tmp보다 큰 경우
- 장점: 이미 정렬을 마쳤거나 정렬이 거의 끝나가는 상태에서는 빠름
- 단점: 삽입할 위치가 멀리 떨어져있으면 이동 횟수가 많아짐

## 셸 정렬(shell sort)
- 단순 삽입정렬을 개선한 알고리즘
- 정렬할 배열의 원소를 그룹으로나눠서 그룹별로 정렬 수행
- [참고 링크](https://ko.wikipedia.org/wiki/%EC%85%B8_%EC%A0%95%EB%A0%AC)

## 퀵 정렬(quick sort)
- 배열을 두 그룹으로 나눔
  - a[pl] >= x 가 성립하는 원소를 찾을 떄 까지 pl을 오른쪽 방향으로 스캔
  - a[pr] <= x 가 성립하는 원소를 찾을 떄 까지 pr을 왼쪽 방향으로 스캔
  - pl 과 pr이 교차하면 그룹을 나누는 과정이 끝남
  - 피벗 이하인 그룹: a[0], ... , a[pl - 1]
  - 피벗 이상인 그룹: a[pr + 1], ... , a[n - 1]
  - 피벗과 일치하는 그룹: a[pr + 1], ... , a[pl - 1] (pl > pr + 1일 경우에)

- [참고 링크](https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC)